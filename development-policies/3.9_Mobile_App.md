# 3.9 Mobile App

1. ### Project Overview {#project-overview}

Our mobile app is an integral part of an innovative IoT smart heating system. Designed for users of our cutting-edge heating solution, the app is set to help guide through all installation steps. As we value comfort and experience of our users we try to provide intuitive control and monitoring capabilities. We value privacy as much so we also offer remote and local modes of operation to choose from.

2. ### Core Principles {#core-principles}

Clean architecture is a set of design principles that divides software components/modules into onion ring-like layers. The main idea is that code dependencies are supposed to only go from the outer layers to the inner ones.

Clean Architecture’s eight design principles and development rules:

* Dependency rule.

At the core of Clean Architecture's dependency rule is the control of dependency direction. Each layer may have dependencies, but these must only point inward. Inner layers remain oblivious to outer layers, ensuring a clear hierarchy. For instance, while an adapter layer might depend on a component in the application layer, the reverse is not allowed. This design enforces a unidirectional dependency flow, preserving the separation of concerns and integrity of each layer.

* Abstraction principle.

The abstraction principle in Clean Architecture dictates that business logic resides in the business rules and application layers, with the most abstract concepts at the core. Conversely, implementation details belong to the adapter and infrastructure layers, which are more concrete and form the outer circles. This principle ensures a clear distinction between abstract business logic and concrete implementation details, maintaining a structured and organized codebase.

* SOLID.

SOLID is a set of five object-oriented design principles aimed at creating software that is easy to maintain, extend, and adapt. These principles guide the development of a software architecture that is both simple and flexible, ensuring long-term sustainability and efficiency in managing complex software systems.

* Reuse/release equivalence principle (REP).

REP emphasizes that each release should consist of related classes or modules that form a cohesive unit. This ensures that any class or module in a release is not only reusable but also part of a well-defined, tracked release process. The principle discourages the inclusion of unrelated components in a single release, fostering a more organized and manageable codebase.

* Common closure principle (CCP).

CCP advocates that classes within a component should be bound together, meaning if you use one, you typically use all. This principle mirrors the Interface Segregation Principle from SOLID, ensuring classes don’t carry unused methods. It promotes a tightly-knit component structure where classes are closely related and changes to one likely necessitate changes to others, enhancing maintainability and logical coherence.

* Acyclic dependency principle (ADP).

ADP targets the elimination of dependency cycles within components, advocating for a structure where changes are manageable and straightforward. Dependency cycles complicate modifications, so ADP ensures no such cycles exist in an application. Breaking these cycles is often achieved through effective use of dependency injection, leading to a more modular and easily adaptable architecture.

* Ports and Adapters.

Ports and Adapters, also known as the hexagonal architecture pattern, play a key role in Clean Architecture. Ports represent application interfaces, independent of technology, while adapters connect these ports to technology-specific components. This pattern allows for a clear separation of concerns, as the application and ports remain agnostic to technology-specific details handled by adapters, thereby enhancing modularity and flexibility in the system design.

Five rules of SOLID:

* Single Responsibility Principle (SRP): Each class should have only one reason to change, ensuring simplicity and clarity in its responsibilities.  
* Open/Closed Principle (OCP): Software entities should be open for extension but closed for modification, promoting scalability and flexibility.  
* Liskov Substitution Principle (LSP): Objects of a superclass should be replaceable with objects of its subclasses without affecting the application's correctness.  
* Interface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they do not use, encouraging lean and targeted interfaces.  
* Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules; both should depend on abstractions, fostering decoupling and ease of updates.

Adopted principles promote ease of maintenance and separate testing of each component from business rules down to implementation details. The benefits that should also be mentioned are separation of concerns and loose coupling between application parts. \[Project is ready if the team decides to fully adopt SOLID. Due to the rapid speed of development in early stages we didn’t follow the open-closed principle closely.\]

\[Testing is non-existent at this point but HIGHLY encouraged. I believe we should write tests at various levels (unit, widget, integration) at least for critical business processes with high levels of complexity. \<Project’s testing practices description ensues if we do, recommendations and encouragement for such practices if we don’t\>.\]

\[Code documentation can also be considered non-existent but, again, HIGHLY encouraged. \<Project’s code documentation practices description ensues if we do, recommendations and encouragement for such practices if we don’t\>.\]

3. ### Project Structure {#project-structure}

The structure of the project facilitates separation of concerns and modular development by being organized into clear, modular sections which is well aligned with Clean Architecture principles.

The core layer of the application contains fundamental elements like bootstrap essentials, constants and utilities. This layer is important for global configurations and all kinds of constants (e.g. Strings, Dimensions and so on) to avoid having “magic numbers” in code. This leads to better maintainability as well as having a single place with all setting values.

The features layer encapsulates each feature into its own directory making it easy to implement feature flags. We like to think ahead\! Furthermore each feature is divided into data, domain and presentation layers which also aligns with Clean Architecture by separating the business logic, data handling, and UI. This separation is important for easier testing and maintenance.

The shared layer provides common functionalities and components. The reuse of these components helps maintain consistency and reduce code duplication.

State management of the app is implemented with the popular flutter\_bloc state management library. It is well known by developers and aligns well with Clean Architecture principles. We use functional programming paradigms, which enhance code clarity and error handling. We also stick with data immutability in our data structures with the help of freezed and fast\_immutable\_collections packages, reducing side-effects and improving predictability of application working the way it was meant to work.

We depend on the flutter\_screenutil package for UI scaling including various dimensions and fonts. We use SVG format so our images scale as well.

The use of dependency injection and service locator pattern is crucial for maintainability and testability of the app. This also aligns well with SOLID principles and allows for loose coupling which, again, aligns with Clean Architecture principles.

The use of declarative navigation over imperative one allows for better readability and maintainability. It also improves consistency as navigation state is managed centrally and facilitates deep linking, allowing users to navigate directly to specific screens within the app. Declarative navigation better supports state restoration which is crucial for seamless user experience and allows for easier integration with the overall app state, making it simpler to manage complex navigation scenarios based on user interactions and app state changes.

Coding standards are enforced by a set of rules for dart analyzer which were carefully selected to encourage producing code of the highest quality.

\[Testing is non-existent at this point but HIGHLY encouraged. I believe we should write tests at various levels (unit, widget, integration) at least for critical business processes with high levels of complexity. \<Project’s testing practices description ensues if we do, recommendations and encouragement for such practices if we don’t\>.\]

\[Code documentation can also be considered non-existent but, again, HIGHLY encouraged. \<Project’s code documentation practices description ensues if we do, recommendations and encouragement for such practices if we don’t\>.\]

4. ### Application’s CI/CD Process {#application’s-ci/cd-process}

Configured for the project’s GitLab repository. The process is simple for now. When a merge request (MR) is created the CI/CD pipeline is run. It runs a script that generates code (we use code generation), formats code using dart formatter, analyzes code using dart analyzer and, finally, runs tests (which are almost non-existent at this point). If the CI/CD pipeline succeeds the permission to merge is granted.  
\[There is no release process integrated into CI/CD for now. This should be updated later.\]
